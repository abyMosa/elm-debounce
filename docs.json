[{"name":"Debounce","comment":"\n\n@docs Debounce, DebounceMsg, event, init, push, update\n\n","unions":[{"name":"Debounce","comment":"\n\n    The `Debounce` type keeps track of messages it's received in a\n    particular burst. Every message added to the list schedules a check some time\n    in the future; if the list hasn't changed in that time we emit the newest\n    message in the list and discard the rest.\n\n","args":["msg"],"cases":[["Debounce",["{ cooldown : Basics.Int, queue : List.List msg, tagger : Debounce.DebounceMsg msg -> msg }"]]]},{"name":"DebounceMsg","comment":"\n\n    A type for messages internal to the Debounce.\n\n","args":["msg"],"cases":[]}],"aliases":[],"values":[{"name":"event","comment":"\n\n    An obvious condidates for rate-limiting events are buttons. We can use\n    `Debounce.event` to limit these events right at the source, in the HTML.\n\n    For example, we may have a pagination component that sends out a HTTP request\n    every time the page changes to fetch new content. We want to prevent a sudden\n    burst of requests being sent if the user clicks the \"next page\" button multiple\n    times so we create a debouncer and use that to limit the number of events that\n    will be produced by the HTML.\n\n    As a rule of thumb, if you don't need any data from the event itself then\n    `Debounce.event` is a good choice to avoid cluttering up the `update` function\n    with needless logic.\n\n    Html.button\n    [ Html.Events.onClick (Debounce.event Increment model.debouncer) ][ Html.text \"+\" ]\n\n","type":"msg -> Debounce.Debounce msg -> msg"},{"name":"init","comment":"\n\n    A debouncer limits messages by waiting for a burst of messages to settle\n    before emitting the most recent message. This means they'll always be a brief\n    delay even if only one message is received; this is demonstrated below.\n\n        --a-b-cd--e----------f--------\n        ---------------e----------f---\n\n    -- params\n    tagger: function that will wrap the Debounce's internal `DebounceMsg` type\n    cooldown: the delay between the last message in a burst being sent and that message being emitted\n\n","type":"(Debounce.DebounceMsg msg -> msg) -> Basics.Int -> Debounce.Debounce msg"},{"name":"push","comment":"\n\n    Sometimes we don't want to limit events coming from the HTML, but we want\n    to limit how often we perform an action based on that event instead. A typical\n    example is searching for things on the backend in realtime as the user types.\n\n    We don't want to send a HTTP request on each keypress, but we also don't want\n    to limit the events coming from the HTML otherwise we'll lose the user's input.\n    In these cases we use `Debounce.push` to manually push messages into the\n    Debouncer.\n\n    update msg model =\n        case msg of\n            GotInput input ->\n                Debounce.push (SearchFor input) model.debouncer\n                    |> Tuple.mapFirst\n                        (\\debouncer ->\n                            { model\n                                | debouncer = debouncer\n                                , input = input\n                            }\n                        )\n\n            SearchFor input ->\n                ( model\n                , Http.get\n                    { ...\n                    }\n                )\n\n","type":"msg -> Debounce.Debounce msg -> ( Debounce.Debounce msg, Platform.Cmd.Cmd msg )"},{"name":"update","comment":"\n\n    You don't need to do much with this function, just ensure that you're calling\n    it in your update function whenever you get a wrapper message:\n\n    update : Msg -> Model -> (Model, Cmd Msg)\n    update msg model =\n        case msg of\n            ...\n            DebounceMsg debounceMsg ->\n                Debounce.update debounceMsg model.debouncer\n                    |> Tuple.mapFirst (\\debouncer -> { model | debouncer = debouncer })\n\n","type":"Debounce.DebounceMsg msg -> Debounce.Debounce msg -> ( Debounce.Debounce msg, Platform.Cmd.Cmd msg )"}],"binops":[]}]